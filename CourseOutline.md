
DotNetC#
C# Development Fundamentals


C# is the most commonly used language for leveraging the .NET Framework. As such, learning C# is a springboard to creating enterprise systems, desktop applications, websites and mobile applications. The goal of this learning path is to take you from having little to no experience with C# to understanding how to leverage the language's advanced features and how it works on the CLR. 

SKILL IQ
MEASURE YOUR SKILL IQ TO FIND WHAT TO START

RELATED TOPICS
.Net developer 

web developer 

software engineer

 ASP.Net 

Visual Studio 

WPF



What you will learn
C# syntax

Object oriented paradigm

Arrays, lists, dictionaries

Interfaces

Generics

Events, delegates, and lambdas

LINQ

Asynchronous programming

Pre-requisites
No prior C# knowledge or experience is needed. Some understanding of common programming concepts, such as variables and looping, will be helpful.



INTRODUCTION TO C#
Do you want to become productive with C#? This beginner area is the perfect place to start. These C# tutorials are designed to give you everything you need to become a productive C# developer. By the end of this section, you’ll have a firm understanding of the C# language and valuable insights on how things work under the hood.



C# THE BIG PICTURE
C# is one of the most widely used programming languages for modern software development; combining the resilience and safety typical of managed languages with the speed and performance of natively compiled languages. In this course, C#: The Big Picture, you'll gain the ability to understand C#'s role in modern software development, evaluate whether C# is the right language for your needs, and kick start your journey to C# fluency. First, you'll discover the key characteristics of C# that make it one of the top 5 most popular programming languages in the world today. Next, you'll explore the incredible power of managed execution in .NET using C#, and gain a critical understanding of the relationship between C#, the .NET runtime, and the .NET base class libraries. Finally, you'll become acquainted with some of the syntax of C#, its pattern of evolution over time, and what to expect moving forward if you invest in further study. When you're finished with this course, you'll know enough about C# and .NET to know whether C# is the right language for you, understand critical context required to work with C# developers or continue your own journey to C# mastery, and know what to expect as C# continues to evolve in the future.

A. Course Overview
B. DISCOVERING C#
Introduction

Tools Used in This Course

Historical Context

Approachable

Strongly Typed

Resilient and Safe

Object-oriented with Functional Features

Open-source, Cross-platform, and General Purpose

Conclusion

C. Exploring Managed Execution in C#
Introduction

Code Execution Models

The Common Language Runtime (CLR)

Just-in-Time (JIT) Compilation Revealed

The .NET Base Class Libraries

Putting the CL in CLR

Conclusion

D. The Constant Evolution of C#
Introduction

Principles of C# Evolution

Top Level Programs

Properties

Expression-bodied Members

Disposable Types

Relational Patterns

Conclusion

C# GETTING STARTED
C# is one of the most popular programming languages, but it’s also intimidating. There is so much going on, even in a simple program! The first step into C# can feel like climbing a brick wall.

In this course, C#: Getting Started, you’ll set up a development environment and run a tiny “Hello, World!” program. Granted, that program will have many moving parts. Fear not: you'll explore those parts one by one, until you have a clear idea of everything that is going on.

First, with the help of a pre-baked piece of code, you’ll turn the simplistic program into a usable command-line utility. Next, you’ll find and fix a bug together in Microsoft Visual Studio. Finally, you’ll look into a couple of more advanced C# features: structs and properties.

By the end of this course, C# won’t look so intimidating anymore. That brick wall will be behind you, and you’ll be on your path to become a C# developer.

A. Course Overview
B. Getting Ready to Code
Welcome to C#!4m

How to Watch This Training1m

The C# Development Stack1m

Version Check1m

Downloading Visual Studio2m

Installing Visual Studio1m

Generating a Program4m

C. Exploring C#'s Building Blocks
A Short Hike through C#3m

Static Methods5m

Juggling Types7m

Static Typing3m

Built-in Types3m

Type Inference2m

Arrays1m

Back to the Base Camp4m

D. Assembling a C# Program
Using Multiple Files1m

A Tiny Library3m

Referencing Libraries2m

Cleaning up the Class5m

The Case for Namespaces5m

Importing Namespaces2m

Goodbye, "Hello, world!"2m

A Bit of Sugar2m

Controlling Access3m

Fleshing Out the Program4m

E. Hunting for Bugs
Meet the Debugger2m

Stepping through the Code3m

Second Try!3m

The Debugger Is Your Friend2m

F. Wrapping It Up
A Look Back1m

C# and Smart IDEs7m

Welcome to C# (Again)!1m

CONTROLLING PROGRAM FLOW IN C#
Nearly every modern application requires structured logic to make decisions and manage repetitive tasks. In this course, Controlling Program Flow in C#, you’ll learn to use different types of C# statements to control the execution flow of your apps. First, you’ll explore how statements form the building blocks of C# code, and use simple statements and expressions to calculate values and handle logical comparisons. Next, you’ll discover how to use conditional selection statements to create branching paths of logic in your apps. Finally, you’ll learn how to manage repetitive tasks and work with sets of data using loops and iteration statements. When you’re finished with this course, you’ll have the skills and knowledge of C# statements needed to control the logic and flow of meaningful applications.

A. Course Overview2m
B. Working with C# Statements
What Is Program Flow?3m

Demo: Setting up the Sample Project4m

Understanding C# Statements4m

Demo: Writing Simple Statements4m

Exploring Statements and Expressions4m

Demo: Working with Expression Statements3m

Demo: Making Logical Comparisons with Statements4m

Demo: Stepping through Program Flow2m

Summary1m

C. Branching Program Flow with Selection Statements
Exploring Selection Statements3m

Demo: Creating a Simple Selection Statement5m

Demo: Creating a Branching Selection Statement2m

Demo: Complex Decisions Using Selection Statements3m

Exploring Switch Statements3m

Demo: Working with Switch Statements3m

Demo: Organizing the Application Code4m

Summary1m

D. Looping through Tasks with Iteration Statements
Understanding Iteration Statements4m

Demo: Processing Data with a For Loop6m

Exploring Different Types of Loops4m

Demo: Simplifying Loops with Foreach3m

Demo: Working with While Statements4m

Demo: Understanding Variable Scope4m

Demo: Organizing the Application Reports3m

Summary1m

E. Exploring Additional Program Flow and Statement Features
Going Further with Flow and Statements1m

Demo: Controlling Flow through User Input3m

Demo: Enhancing Program Flow Using Loops4m

Demo: Program Flow Considerations with Dynamic Data4m

Demo: Generating Reports Using Dynamic Data5m

Exploring Advanced Selection Statement Features3m

Demo: Exploring Additional Switch Statement Features4m

Demo: Streamlining if-else Selections3m

Demo: Touring a Finalized App State3m

Summary2m



INTRODUCTION TO THE C# TYPE SYSTEM
Since C# is a strongly-typed language, everything you work with has to have a type defined. It's vital to know how to create your own custom types like classes, interfaces, enums, and structs. In this course, Introduction to the C# Type System, you’ll learn about the type system in C#. First, you’ll explore the built-in data types, including int, string, and DateTime. Next, you’ll understand the difference between value types and reference types and you’ll see how to create your own types, be that classes, enums, interfaces, or structs. Finally, you’ll learn about the different aspects offered by C# to create classes including inheritance. When you have finished this course, you’ll understand the different value types and reference types in C# needed to create any .NET application using C#.

A. Course Overview
B. Course Introduction
Module Introduction1m

What Will You Learn from This Course?3m

Required Tools1m

C. Using Built-in C# Data Types
Module Introduction1m

Understanding Types in C#6m

Using Built-in Data Types2m

Demo: Working with Primitive Types5m

Expressions in C#2m

Demo: Operators and Default Values4m

Members on Primitive Types2m

Demo: Working with Members of int and char3m

Working with DateTime2m

Demo: Working with DateTime6m

Converting between Types3m

Demo: Converting between Types3m

Implicit Typing2m

Demo: Implicit Typing2m

Summary1m

D. Creating and Using Strings
Module Introduction1m

Understanding Strings in C#3m

Demo: Creating Strings2m

Working with Strings5m

Demo: Working with Strings6m

Escaping Text2m

Demo: Escaping Text3m

Testing Strings for Equality1m

Demo: Comparing Strings2m

The Immutability of Strings5m

Demo: Strings are Immutable5m

Parsing from Strings to Other Types2m

Demo: Parsing Strings3m

Summary1m

E. Working with Methods
Module Introduction1m

Understanding Methods6m

Demo: Creating Methods6m

Finding the Correct Method2m

Demo: Method Overloading3m

Passing Parameters by Value and by Reference3m

Demo: Passing Parameters by Value and by Reference4m

Demo: Using the out Keyword3m

Using params2m

Demo: Using params2m

Optional Parameters and Named Arguments2m

Demo: Optional Parameters and Named Arguments3m

Demo: Using Expression-bodied syntax2m

Summary1m

F. Understanding Value Types and Reference Types
Module Introduction1m

The Common Type System6m

Understanding Custom Types4m

Demo: Browsing for Custom Types6m

Creating Enumerations2m

Demo: Creating Enumerations6m

Working with Structs3m

Demo: Working with Structs3m

Summary1m

G. Creating Your First Class and Objects
Module Introduction1m

Understanding Classes4m

Creating the Employee Class4m

Demo: Creating the Employee Class6m

Using the Class9m

Demo: Creating Objects7m

Demo: Working with Several Objects2m

Demo: Classes Are Reference Types3m

Adding Properties3m

Demo: Adding Properties6m

Demo: Building the Employee Registration Application6m

Summary1m

H. Doing More with Custom Types
Module Introduction1m

Grouping Classes in Namespaces2m

Demo: Working with Custom Namespaces4m

Introducing Static Data4m

Demo: Working with Static Data and Methods5m

Demo: Working with Constant Data2m

Working with null4m

Demo: Working with null4m

Understanding Garbage Collection3m

Demo: Understanding Garbage Collection3m

Summary1m

I. Applying Inheritance to C# Types
Module Introduction1m

Understanding Inheritance3m

Creating a Base and a Derived Type4m

Demo: Creating a Base and a Derived Type10m

The Is-A Relation1m

Demo: The Is-A Relation2m

Using Polymorphism6m

Demo: Using the virtual and override Keywords7m

Demo: Working with Sealed Classes2m

Abstract Classes3m

Demo: Working with Abstract Classes6m

Inheriting from System.Object2m

Demo: Inheriting from System.Object2m

Summary1m

J. Using Interfaces
Module Introduction1m

Understanding Interfaces5m

Demo: Creating a Custom Interface4m

Exploring and Using Built-in Interfaces2m

Demo: Using IComparable4m

Using Polymorphism with Interfaces1m

Demo: Using Polymorphism with Interfaces1m

Summary and Course Closing1m

C# INTERFACES
Code that is easy to maintain, extend, and test is key to applications that can move quickly to meet your users’ needs. In this course, C# Interfaces, you’ll learn to use interfaces to add flexibility to your code. First, you’ll explore the mechanics (“What are interfaces?”) and why you want to use them. Next, you’ll discover how to create your own interfaces to make it easy to change or swap out functionality. Finally, you’ll learn about default member implementation and how to avoid some common stumbling blocks. When you’re finished with this course, you’ll have the skills and knowledge of C# interfaces needed to write application code that is easy to maintain, extend, and test.

A. Course Overview1m
B. Introducing Interfaces
Course Overview5m

Definitions3m

Demo: Concrete Class, Abstract Class, and Interface13m

Programming to an Abstraction3m

Demo: Future-proofing Code10m

Summary1m

C. Creating Interfaces to Add Extensibility
Overview1m

The Repository Pattern4m

Demo: Implementing an Interface (Service Reader)11m

Demo: Other Data Readers (CSV, SQL)8m

Reader Factory1m

Demo: Reader Factory7m

Summary2m

D. Dynamic Loading and Unit Testing
Overview2m

Selecting a Data Reader at Run-time2m

Demo: Configuring a Data Reader7m

Dynamic Loading4m

Demo: Dynamic Reader Factory6m

Results of Dynamic Loading1m

Unit Testing and Dependency Injection3m

Demo: Using Dependency Injection5m

Demo: Unit Testing7m

Summary2m

E. Explicit Interface Implementation
Overview1m

Explicit Implementation3m

Demo: Calling Explicitly Implemented Members4m

Using Explicitly Implemented Members5m

Demo: Implementing IEnumerable4m

Summary1m

F. Default Implementation and Advanced Topics
Overview1m

Changing Interfaces2m

Default Implementation2m

Demo: Adding Default Implementation8m

Calling Default Implemented Members2m

Demo: Calling Default Implemented Members3m

Beware of Unintended Behavior2m

Demo: Making Bad Assumptions3m

Interface Inheritance3m

Additional Features4m

Interfaces vs. Abstract Classes4m

Summary2m

C# GENERICS
Generics are a powerful feature of the C# language, they allow you to write type-safe, reusable, and performant code. In this course, C# Generics, you’ll learn to build and use generic types in your .NET applications. First, you’ll explore the need for generics in C#. Next, you’ll discover how to build and use generic classes, interfaces, methods, and delegates. Finally, you’ll learn how generics behave in special cases, like with static members and mathematical operators. When you’re finished with this course, you’ll have the skills and knowledge of C# Generics needed to build and use your own generic types in your .NET applications.

A. Course Overview1m
B. Understanding the Need for Generics
Introduction2m

How This Course Is Structured2m

Implement a Stack Class for Doubles9m

The New Requirement2m

Use Object to Support Any Type8m

Copy and Paste for Victory4m

Create a Generic Stack Class5m

Know the Advantages of Generics2m

Use the Stack<T> Class of .NET3m

Summary1m

C. Implementing Generic Classes
Introduction1m

Understand the Scenario3m

Create a .NET Console Application8m

Implement a Generic Class5m

Inherit from a Generic Class3m

Use Multiple Type Parameters7m

Add a Generic Type Constraint8m

Work with the Class Constraint6m

Use the New() Constraint4m

Summary2m

D. Working with Generic Interfaces
Introduction1m

Why Use a Generic Interface?4m

Build a SqlRepository<T> Class10m

Create a Generic Interface6m

Use an Existing Generic Interface6m

Understand Covariance8m

Understand Contravariance10m

Work with Interface Inheritance4m

Summary2m

E. Creating Generic Methods and Delegates
Introduction1m

Add a Non-generic Method3m

Create a Generic Method7m

Build a Generic Extension Method4m

Write a Generic Method with Return Value6m

Add a Non-generic Delegate4m

Create a Generic Delegate3m

Understand Variance with Generic Delegates5m

Use the Action<T> Delegate2m

Create Events with EventHandler<T>5m

Summary1m

F. Knowing the Special Cases with Generics
Introduction1m

Use Static Members in Generic Classes6m

Create Generic Methods in Generic Classes3m

Work with Mathematical Operators5m

Summary2m

C# LANGUAGE FEATURES
Once you have a strong foundation with C#, you can now start fine tuning your skills to create code that is more maintainable, extensible, and object-oriented. The C# courses in this section will provide everything you need to know to take advantage of the rich feature set C# provides.

WORKING WITH C# RECORDS
As a developer you want to write quality code with as few bugs as possible. In this course, Working with C# Records, you’ll learn to make your code bug resistant using immutability and Records. First, you’ll explore the concept of immutability. What it is and why it improves software quality. Next, you’ll discover Records, which will make working with immutability in C# a breeze. Finally, you’ll learn the features of Records, which will make working with them a pleasure. When you’re finished with this course, you’ll have the skills and knowledge to apply immutability and records to your software needed to mitigate those nasty bugs.

A. Course Overview1m
B. The Case for Immutability
Introduction1m

Classes and Reference Types Refresher5m

Comparing Records to Classes3m

The Need for Immutability4m

Immutability in Front-end Applications6m

Summary1m

C. Records in Action
Introduction1m

Refactoring: From Classes to Records3m

Destructuring3m

Passing by Reference2m

Cloning6m

Custom Record Types5m

Inheritance and Polymorphism5m

Summary1m

D. Working with Synthesized Methods
Introduction1m

Virtual Members Refresher2m

What are Synthesized Methods?7m

Converting to a String3m

Equality7m

Summary1m

WORKING WITH ARRAYS & COLLECTIONS IN C#
Real-world apps almost always require manipulating sets of data, and in C# apps, that data is normally held in collections. In this course, Working with Arrays and Collections in C#, you’ll learn how to use collections to access your data. First, you’ll discover how to look up and enumerate data in an array – the simplest of the collections. Next, you’ll learn how to add and remove data using a list, and how dictionaries can aid efficient look up by using a key. Then, you’ll delve into easily combining sets of data using the HashSet collection. Finally, you'll explore how to process data using stacks and queues, and make modifications more efficient with linked lists. By the end of the course, you’ll have a better understanding of the skills needed to work with your data in C# using collections.

A. Course Overview2m
B. Storing Data in an Array
Overview2m

Introducing Arrays4m

Enumerating with the foreach Loop3m

Looking up Items4m

Controlling Enumeration with the for Loop2m

Instantiating an Array without Data2m

Setting Array Elements2m

Summary1m

C. Finding Data in an Array
Overview2m

Finding Elements with a foreach Loop4m

Finding Elements with Array.Find()3m

The System.Array Class3m

Finding Multiple Items with FindAll()3m

An Array as a Property3m

Array.Exists() to Look for a Value3m

Summary1m

D. Adding and Removing Data with List<T>
Overview1m

'Resizing' an Array with Array.Resize()3m

The Problem with Array.Resize()3m

Introducing List<T>2m

Removing Items with List<T>.RemoveAt()2m

Removing Items with List<T>.RemoveAll()2m

List Initializers2m

Comparing Lists and Arrays3m

Summary1m

E. Dictionaries
Overview1m

The Problem with Array.Find()2m

What Is a Dictionary?2m

Instantiating a Dictionary2m

Looking up Values with a Key2m

TryGetValue() and ContainsKey()3m

Enumerating Dictionaries2m

The SortedDictionary Collection3m

The SortedList Collection2m

Summary1m

F. Sets
Overview2m

Separating Concerns in the Demo2m

Solving the Problem with Array.Find()3m

Set Intersection2m

Intersection with HashSet<T>3m

More HashSet Operations: Union and Except2m

G. Complex Data: Multidimensional and Jagged Arrays
Storing a Grid of Data2m

Instantiating a Multidimensional Array2m

Putting the 2D Array in a Class1m

Enumerating a 2D Array2m

Jagged Arrays3m

Summary1m

H. Stacks and Queues
What Is a Queue?1m

Introducing the Demo: Passengers Queueing2m

Enqueuing and Dequeuing4m

Introducing the Stack2m

Pushing and Popping on a Stack3m

Summary1m

I. Adding Data Efficiently with Linked Lists
What Is a Linked List?2m

Storing Data in a Linked List1m

Iterating and Removing from a Linked List3m

Running the Demo2m

Linked List Pros and Cons1m

Course Summary1m

A Final Challenge1m

C# EXTENSION METHODS
Real-world apps almost always require manipulating sets of data, and in C# apps, that data is normally held in collections. In this course, Working with Arrays and Collections in C#, you’ll learn how to use collections to access your data. First, you’ll discover how to look up and enumerate data in an array – the simplest of the collections. Next, you’ll learn how to add and remove data using a list, and how dictionaries can aid efficient look up by using a key. Then, you’ll delve into easily combining sets of data using the HashSet collection. Finally, you'll explore how to process data using stacks and queues, and make modifications more efficient with linked lists. By the end of the course, you’ll have a better understanding of the skills needed to work with your data in C# using collections.

A. Course Overview
B. Getting Started with Extension Methods
Why You Need to Master Extension Methods4m

Demo: Using Extension Methods4m

Understanding Extension Methods3m

Demo: Writing Extension Methods5m

Demo: Extending .NET's Configuration Library4m

Knowing What You Can and Can't Do with Extension Methods3m

Demo: The Limitations of Extension Methods5m

Module Summary2m

C. Best Practices for Using Extension Methods
Extension Method Best Practice Guidelines5m

Demo: Simple Extension Methods, Good and Bad4m

Guidelines for Private Extension Method Libraries3m

Demo: Extension Method Assemblies Split by Scope6m

Guidelines for Public Extension Methods3m

Demo: Exploring Extension Methods in Entity Framework and Serilog6m

Module Summary2m

D. Building Your Own Extension Method Library
Why You Should Build an Extension Method Library2m

Demo: Extension Methods for User Experience4m

Demo: Extensions for New Features3m

Demo: Extensions for Non-functional Requirements6m

Demo: Extensions for Production Readiness6m

Demo: Publishing the Extension Method Library5m

Course Summary2

C# LANGUAGE-INTEGRATED QUERY (LINQ)
LINQ can filter and extract data from collections much more efficiently and with less code. In this course, C# Language-Integrated Query (LINQ), you’ll learn over 60 LINQ queries using C#. First, you’ll explore why you should use LINQ, how to select, order, filter and extract data using LINQ queries. Next, you’ll discover how to use LINQ queries to work with multiple collections, group and aggregate data. Finally, you’ll learn what goes on under the hood with LINQ queries by understanding deferred execution. When you’re finished with this course, you’ll have the skills and knowledge of LINQ needed to query data efficiently and with less code from any collection of data.

A. Course Overview2m
B. Why You Should Use LINQ
Why It's Important to Watch This First Module2m

LINQ Basics and the Common IEnumerable Types1m

Comparing SQL to LINQ and Query to Method Syntax3m

The Many LINQ Operations2m

LINQ to Objects and LINQ Integrations3m

C. Using LINQ Select and Order Operations
The Project, Classes, and Data Used in this Course4m

Select All Items Using a Simple Loop3m

Select All Items Using LINQ4m

Select a Single Column2m

Select Specific Columns of Data2m

Build an Anonymous Class3m

Ordering Data2m

Ordering Data in Descending Order1m

Ordering Data Using Multiple Fields3m

D. Extract Data Using Filtering and Element Operations
Filter Data Using a Where Expression2m

Using a Where Expression with Two Fields1m

Using a Custom Extension Method for Filtering2m

Select a Single Item Using First() and FirstOrDefault()3m

Select a Single Item Using Last() and LastOrDefault()2m

Select a Single Item Using Single() and SingleOrDefault()3m

E. Extract Distinct Values, Assign Values and Partition Collections
Assigning Values to Properties Using LINQ4m

Calling a Method to Set a Property3m

Get a Specific Amount of Items Using Take()1m

Using TakeWhile() to Select a Specific Amount of Items1m

Using Skip() and SkipWhile() to Pass Over Items2m

Getting Unique Values from a Collection using Distinct()2m

F. Identify What Kind of Data Is Contained in Collections
Using All() to See if All Items Match a Condition3m

Using Any() to See if Any Items Match a Condition1m

Using Contains() with an Integer List of Items2m

What Is an EqualityComparer Class?2m

Demo of EqualityComparer with Contains()3m

G. Compare and Union Two Collections
Using SequenceEqual() to Compare Two Collections3m

Using SequenceEqual() with an EqualityComparer3m

Except() Finds Values in One List, but Not the Other3m

Intersect() Finds Values in Common between Two Lists2m

Concat() and Union() Two Lists Together3m

H. Joining Two Collections Together
Performing an Inner Join with LINQ4m

Inner Join with Two Fields2m

Creating a One-to-many Structure Using Group Join4m

Creating a Left Outer Join Using Query Syntax3m

Creating a Left Outer Join Using Method Syntax2m

I. Creating Groups of Data Using GroupBy
Grouping Data Using Group By in LINQ3m

Group By Using 'into' and 'select'2m

Filtering the Grouped Results Using 'where'2m

Creating a One-To-Many Structure Using a Subquery3m

Creating a Subquery Using the Method Syntax1m

J. Aggregating Data in Collections
Count() and Filtering the Count() Method3m

Using Min() and Max()2m

Using Average() and Sum()2m

Custom Calculations Using the Aggregate() Method3m

Calculating Aggregates for Groups of Data3m

A More Efficient Way to Aggregate Data5m

K. Understanding Deferred Execution in LINQ
Understanding the Types of LINQ Execution2m

Deferred vs. Immediate and Streaming vs. Non-streaming3m

Deferred Execution and GetEnumerator()6m

Create Your Own Filtering Extension Method5m

Streaming vs Non-Streaming Demonstration2m

Create Your Own Streaming Extension Method3m

Using 'yield' with Take() and OrderBy()2m


APPLIED C#
The courses in this section will provide valuable insight into the finer points of the C# language. This includes a deep dive into creating code with interfaces, the use of extension methods and lambda functions. Finally you will wrap up by gaining an understanding of C# concurrent collections and various tips to be an effective C# developer.


EXCEPTION HANDLING IN C#
Missing or incorrectly implemented error handling code can lead to data corruption, unnecessary crashes, annoyed end-users, out-of-hours support calls, and hard to maintain code. In this course, Exception Handling in C#, you’ll gain the ability to correctly handle runtime errors in your C# applications. First, you’ll explore what exceptions are and why we use them. Next, you’ll discover how to respond to errors that occur in your applications at runtime. Finally, you’ll learn how to throw exceptions in your own code and even how to define your own custom exception classes. When you’re finished with this course, you’ll have the skills and knowledge of C# exception handling needed to handle runtime errors in your C# applications.

A. Course Overview1m
B. Understanding the Importance of Error Handling
Introduction1m

Course Overview1m

Why Handle Errors?2m

Error Handling Using Error Codes3m

Why Exceptions?1m

What Is an Exception?1m

Summary1m

C. Understanding the Exception Class Hierarchy
Introduction1m

What Does an Exception Represent?1m

The Exception Class Hierarchy1m

The System.Exception Base Class4m

Commonly Used System.Exception Constructors1m

System.ApplicationException Guidelines1m

Commonly Encountered Exceptions4m

Summary1m

D. Getting Started with Exceptions
Introduction1m

Understanding Exception Handling1m

Introducing the Try Statement3m

Demo Code Overview4m

Causing an Exception2m

Understanding the Stack Trace1m

Creating and Throwing an Exception3m

Getting Started with Exception Catching4m

Exception Handling Good Practices3m

Summary1m

E. Catching, Throwing, and Rethrowing Exceptions
Introduction1m

Throwing Exceptions from Expressions4m

Catching Different Exception Types with Multiple Catch Blocks3m

Understanding the Finally Block2m

Rethrowing Exceptions and Preserving the Stack Trace3m

Catching and Wrapping Exceptions3m

Filtering Catch Blocks with Exception Filters3m

Global Unhandled Exception Handling3m

Summary1m

F. Creating and Using Custom Exceptions
Introduction1m

Understanding Custom Exceptions4m

Defining a Custom CalculationException3m

Defining a Custom CalculationOperationNotSupportedException3m

Using Custom Exception Classes4m

An Alternative to Custom Exceptions4m

Summary1m

G. Writing Automated Tests for Exception Throwing Code
Introduction1m

Testing Exceptions with NUnit6m

Testing Exceptions with xUnit.net2m

Testing Exceptions with MSTest V21m

Summary, Key Takeaways, and Resources3m





WORKING WITH NULLS IN C#
Making use of an object when it is not supposed to be null can result in unexpected exceptions that can cause your program to crash. These unexpected null related errors may cause data loss or corruption, system downtime, and unhappy users. In this course, Working with Nulls in C#, you’ll gain the ability to reduce the likelihood of getting null related exceptions in production. First, you’ll explore which objects can be set to null and how to check for null values. Next, you’ll discover a design pattern to help eliminate null related exceptions. Finally, you’ll learn how to opt-in to the ability to create non-nullable reference types that enable the compiler to detect null-related problems before you even run your application. When you’re finished with this course, you’ll have the skills and knowledge of nulls in C# needed to reduce null related errors in your production code.

A. Course Overview
Course Overview1m

B. Working with Nullable Value Types and Strings
Introduction2m

Reference and Value Types Overview2m

What Is a NullReferenceException?2m

Using Magic Numbers for Null Value Types5m

Introduction to Nullable Value Types with Nullable<T>2m

Refactoring to Nullable<T> and Removing Magic Numbers2m

C# Shorthand for Nullable Value Types1m

Nullable Boolean Values2m

Understanding Null and Empty Strings1m

Checking for Null or Empty Strings2m

Summary2m

C. Accessing and Checking for Null Values
Introduction1m

More on Nullable<T>2m

Using the HasValue and Value Properties3m

Using the GetValueOrDefault Method2m

Comparing Nullable<T> Instances1m

Nullable<T> Conversions and Default Values3m

Overview of C# Null-related Operators1m

Using the Conditional Operator to Check for Nulls2m

Using the Null-coalescing Operator1m

The Null-coalescing Assignment Operator2m

Using the Null-conditional Operator6m

Using the Null-conditional Operator with Null Array Values3m

Thread-safe Null Delegate Invocation1m

Summary2m

D. Eliminating Null Reference Exceptions with the Null Object Pattern
Introduction1m

Introducing the Null Object Pattern2m

Null Object Pattern Overview3m

Example Code without the Null Object Pattern4m

Implementing the Null Object Pattern Using Interfaces2m

Refactoring to a Base Class and Single Null Instance3m

Considerations1m

Summary2m

E. Understanding Nullable and Non-nullable Reference Types
Introduction2m

Overview of Null Features3m

Writing Some Simple Null Code2m

Enabling Non-nullable Reference Types for Specific Lines of Code2m

Enabling Non-nullable Reference Types for an Entire Code File2m

Enabling Non-nullable Reference Types for an Entire Project1m

Treating Nullable Warnings as Errors2m

Specifying That a Reference Is Allowed to Be Null1m

Working with Nullable and Non-nullable Properties5m

Working with Nullable and Non-nullable Method Return Values1m

Using the Null-coalescing and Null-conditional Operators2m

Using the Null-forgiving Operator to Override the Compiler5m

Refactoring Existing Code to Use Non-nullable Reference Types8m

Nullable and Non-nullable Generics4m

Considerations and Limitations3m

Summary2m

F. Using Additional Attributes to Describe Nullability
Introduction1m

An Overview of Null-related Attributes1m

Precondition Attributes Overview1m

Using the AllowNull Attribute3m

Using the DisallowNull Attribute2m

Postcondition Attributes Overview1m

Using the NotNull Attribute2m

Using the MaybeNull Attribute4m

Conditional Postcondition Attributes Overview1m

Using the NotNullWhen Attribute3m

Using the MaybeNullWhen Attribute2m

Using NotNullIfNotNull Attribute2m

Constructor Helper Method Attributes Overview2m

Unreachable Code Attributes Overview1m

Using the DoesNotReturn Attribute3m

Considerations3m

Summary, Resources, and Further Learning3m



IDISPOSABLE BEST PRACTICES FOR C# DEVELOPERS
IDisposable is the only part of the platform where .NET asks for your help. If you don't use IDisposable correctly, the .NET Garbage Collector can't manage memory properly, so your app won't run efficiently, it may have strange errors, and it will eventually crash.

In this course, IDisposable Best Practices for C# Developers, you'll learn to manage object lifetimes and keep your apps running lean. First, you'll see what goes wrong if you don't dispose of objects, and how that can bring your apps down. Then, you'll explore the Garbage Collector to understand how .NET cleans up unused objects. Finally, you'll discover how to implement IDisposable throughout a distributed .NET application. When you’re finished with this course, you’ll have the skills and knowledge of managed and unmanaged memory to keep your .NET apps performing under any load.

A. Course Overview
Course Overview2m

B. Introducing IDisposable
Understanding IDisposable5m

Using Disposable Objects6m

Demo: Working with Disposable Objects4m

Demo: Resource Exhaustion from Not Disposing5m

Best Practice #15m

Demo: Consuming Resources without Disposing6m

Demo: Functional Defects from Not Disposing4m

Module Summary2m

C. What Happens When the Garbage Collector Runs?
Introducing the Garbage Collector3m

How and When the GC Runs4m

Demo: Understanding Garbage Collection5m

Demo: Memory and Object Profiling4m

Managing the Garbage Collector's Workload4m

Demo: Implementing IDisposable3m

Demo: The Full Dispose Pattern3m

How the GC Uses Finalizers3m

Demo: IDisposable and Finalizers3m

Demo: Cleaning up Unmanaged Resources3m

Module Summary5m

D. What Happens if You Don't Dispose?
Approaches for Finding and Fixing Disposable Issues3m

Demo: Finding Problems with Object Lifetimes6m

Demo: Fixing Problems with Static Analysis and Profiling11m

Using Static Analysis to Find IDisposable Issues5m

Demo: Managing Object Lifetime in Modern Apps6m

Demo: Fixing Lifetime Problems with Dependency Injection7m

Disposable Objects and Dependency Injection Special Cases4m

Using IAsyncDisposable with Asynchronous Streams7m

Module Summary2m

E. Just the Best Practices
Must-haves, Nice-to-Haves, and Edge Cases6m



IMPLEMENTING C# UNIT TESTING USING VISUAL STUDIO 2019 AND .NET 5
Every developer knows they should be creating unit tests to improve the quality of their applications. In this course, Basics of Unit Testing for C# Developers, you'll learn how to create unit tests by using Visual Studio.

First, you'll see how easy it is to get started with creating unit tests.

Next, you'll explore how to simplify the unit test process by creating data-driven tests.

Finally, you'll cover how to automate your unit tests by scheduling them to run via the command line utility VSTest.Console.

By the end of this course, you'll have the required skills needed to go on and learn more advanced topics in unit testing.

A. Course Overview
Course Overview2m

B. Why You Need Unit Testing
Introduction to Unit Testing2m

The Tools Available in Visual Studio for Unit Testing2m

Why Test Code?1m

QA Department or Unit Tests?4m

Testing Tools Available to .NET Developers1m

Module Summary1m

C. Your First Unit Tests
What You Are Testing2m

Get Started3m

Create Your FileProcess Class2m

Create Your Unit Test Project4m

Arrange, Act, Assert4m

Exception Handling in Unit Tests4m

Code Coverage1m

Module Summary1m

D. Avoid Hard-Coding in Unit Tests
Avoid Hard-coding Using Constants3m

Use TestContext to Write Into Test Output4m

Build a Settings File to Store Test Configuration5m

Create and Delete File During Testing2m

Create a Unit Test Base Class2m

Module Summary1m

E. Initialization and Cleanup
Goals of This Module1m

Learning the Initialization and Cleanup Attributes2m

The Execution Order of Initialize and Cleanup Methods1m

Create the Assembly Initialize and Cleanup Methods3m

Build the Class Initialize and Cleanup Methods3m

Work With the Test Initialize and Cleanup Methods5m

Module Summary1m

F. Attributes Help You Organize Your Unit Tests
Introduction to Unit Test Attributes1m

Getting the Most Out of the Description Attribute5m

Using Grouping Attributes4m

Ignoring and Timing Out Tests2m

Deploying Files for Testing6m

Module Summary1m

G. Assert Classes Save a Lot of Time
Assert Class Methods2m

Pass a Message to Assert Class Methods2m

Testing String Values2m

Testing for Object Types2m

Checking for a Specific Object Type6m

Using the StringAssert Class3m

Using the CollectionAssert Class5m

Using a Comparer Class for Equivelancy4m

Module Summary1m

H. Consolidate Tests by Making Them Data-Driven
Introduction to Data-driven Testing2m

Create Table to Hold Test Values2m

Create Data-Driven Class and Add SqlClient2m

Create FileExistsTestFromDB Method6m

Store Data-driven Settings in Config File2m

Module Summary1m

I. Automating Unit Tests with VS.Test.Console
Automating Unit Tests1m

Running dotnet test Command2m

Logging to the Console, TRX, and HTML Files3m

Run One Specific Test1m

Run Tests Based on Matching Names1m

Run Tests Based on Attributes2m

Module Summary1m

Course Summary0m





DEFENSIVE CODING IN C#
Great applications perform required operations as expected, help users enter correct data, handle system and application exceptions, and make it easy for future developers to modify and maintain the code. Defensive coding focuses on improving code comprehension through clean code, improving code quality with unit tests, and improving code predictability by building clear methods and preparing for the unexpected. In this course, Defensive Coding in C#, you will gain the ability to strengthen your application’s defenses against the perils awaiting it in the real world. First, you will learn how to improve your code comprehension by following techniques such as the Single Responsibility principle. Next, you will discover how to improve your code quality through unit tests. Finally, you will explore how to improve your code predictability by validating method arguments, handling nulls appropriately, returning predictable results, and managing exceptions. When you are finished with this course, you will have the skills and knowledge needed to strengthen your code’s defenses.

A. Course Overview
Course Overview2m

B. Why Defensive Coding Matters
What Are We Defending Our Code From?4m

What Is Defensive Coding?2m

Protected but Nimble2m

Course Overview2m

C. Strengthening Our Code’s Defenses
Evaluating Weaknesses3m

Improving Code Comprehension6m

Improving Code Quality4m

Demo: Unit Testing4m

Improving Code Predictability4m

Guidelines and Summary2m

D. Validating Method Arguments
Defining Clear Method Signatures6m

Surrounding Our Operations with Conditionals5m

Failing Fast with Guard Clauses4m

Unit Testing for Expected Exceptions3m

Refactoring Our Methods4m

Demo: Refactoring Our Methods3m

Guidelines and Summary2m

E. Handling Nulls
The Billion Dollar Mistake?3m

Declaring Nullable Value Types2m

Defending Our Code from Null Nullable Value Types2m

Defending Our Code from Null Reference Types5m

Reference Type Nullability Features6m

Demo: Reference Type Nullability Features5m

Guidelines and Summary3m

F. Returning Predictable Results
Defining Predictable Method Results3m

Defining ref and out Parameters3m

Returning a Tuple3m

Returning an Object2m

Returning Predictable Results: Validation Methods2m

Returning Predictable Results: Simple Operations3m

Returning Predictable Results: Find and Retrieve Methods2m

Returning Predictable Results: Complex Operations3m

Guidelines and Summary4m

G. Managing Exceptions
What Is Exception Handling?1m

Defending Our Code from Exceptions4m

Throwing .NET Exceptions3m

Creating and Throwing Custom Exceptions4m

Catching What We’re Thrown3m

Guidelines and Summary3m

H. Final Words
Recap4m

Learning More and Closing1m





OBJECT-ORIENTED PROGRAMMING FUNDAMENTALS IN C#
This course takes you through the principles and practices of object-oriented programming (OOP). The course provides you with the firm foundation in OOP that you need to progress to intermediate-level C# courses. It begins by showing you how to turn a set of words into a set of well-defined and related classes. Through demonstrations, it teaches you key object-oriented concepts such as abstraction, encapsulation, inheritance, polymorphism, and interfaces.

A. Course Overview
Course Overview1m

B. Introduction
Introduction2m

Object != Class3m

Terms in Context3m

What Is Object-oriented Programming?2m

Get the Most from This Course2m

Course Outline2m

C. Identifying Classes from Requirements
Introduction2m

Analyze the Business Problem2m

Start with the Nouns1m

Define Appropriate Members2m

Consider Time2m

Abstraction2m

Encapsulation4m

Summary2m

D. Building Entity Classes
Introduction1m

Layering the Application2m

Building the Business Logic Layer Component2m

Building a Class: Properties5m

Using Snippets3m

Testing the Class2m

Testing the Class: Valid Values5m

Testing the Class: Invalid Values2m

Working with Objects2m

Objects Are Reference Types2m

Static Modifier2m

Checklists and Summary3m

E. Building Entity Classes - Methods
Introduction1m

Building a Class: Methods2m

Testing the Methods2m

Terms3m

Building a Class: Constructors2m

Building the Remaining Classes3m

Checklists and Summary2m

F. Separation of Responsibilities
Introduction1m

Separation of Concerns3m

Revisiting the Class Diagram3m

Building the Address Class1m

Building a Repository Class1m

Testing a Repository Class3m

Building the Remaining Repositories2m

Checklists and Summary3m

G. Establishing Relationships
Introduction3m

Defining the Relationships2m

Types of Relationships2m

Collaboration2m

Composition1m

Composition: References3m

Populating the Referenced Objects3m

Testing a Composition Relationship3m

Composition: Ids3m

Inheritance4m

Checklists and Summary3m

H. Leveraging Reuse through Inheritance
Introduction3m

Secrets of Reuse1m

The .NET Object Class4m

Overriding Base Class Functionality3m

Polymorphism2m

Building a Base Class3m

Demo: Building a Base Class5m

Preparing Overridable Base Class Members4m

Checklists and Summary3m

I. Building Reusable Components
Introduction3m

Scenario3m

Building a Reusable Component2m

Testing the Reusable Component4m

Using the Reusable Component2m

Static Classes3m

Extension Methods4m

Static Method vs. Extension Method1m

Checklists and Summary2m

J. Understanding Interfaces
Introduction2m

Class Interface3m

Interface Metaphors2m

Setting up the Demo4m

Defining an Interface3m

Implementing an Interface3m

Interface-based Polymorphism5m

Checklists and Summary2m

K. Final Words and Next Steps
Introduction1m

Recap4m

Next Steps1m



